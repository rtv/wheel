/////////////////////////////////
// File: wheel.cc
// Desc: experimental
// Created: 2010.6.6
// Author: Richard Vaughan <vaughan@sfu.ca>
// License: GPL
/////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "stage.hh"
using namespace Stg;

static const double VSPEED = 0.4; // meters per second
static const double EXPAND_WGAIN = 1.0;//0.3; // turn speed gain
static const double FLOCK_WGAIN = 0.3; // turn speed gain
static const double SAFE_DIST = 1.0; // meters
static const double SAFE_ANGLE = 0.5; // radians

class Robot
{
public:
	Robot( ModelPosition* p, ModelRanger* r, ModelFiducial* f) 
		: position(p), 
			ranger(r), 
			fiducial(f), 
			best(NULL), 
			best_bearing(0.0),
			best_range(0.0),
			best_heading_error(0.0),
			vis(this)
	{
		assert(position);
		assert(ranger);
		assert(fiducial);
			
		ranger->AddCallback( Model::CB_UPDATE, (stg_model_callback_t)RangerUpdateCb, this ); 
		fiducial->AddCallback( Model::CB_UPDATE, (stg_model_callback_t)FiducialUpdateCb, this );
		
		fiducial->AddVisualizer( &vis, true );

		fiducial->Subscribe();
		ranger->Subscribe();
		position->Subscribe();
	}

	// callback wrappers
	static int RangerUpdateCb( ModelRanger* mod, Robot* robot ){ return robot->RangerUpdate(); }
	static int FiducialUpdateCb( ModelFiducial* fid, Robot* robot ){ return robot->FiducialUpdate(); }

	int RangerUpdate();
	int FiducialUpdate();
	
  ModelPosition* position;
  ModelRanger* ranger;
  ModelFiducial* fiducial;
	
	ModelFiducial::Fiducial* best;  	
	stg_radians_t best_bearing;
	stg_meters_t best_range;
	stg_radians_t best_heading_error; 
	
	class RobotVis : public Visualizer
	{
	public:
		Robot* robot;
		
		RobotVis( Robot* robot ) 
			: Visualizer( "robot", "vis_robot" ), robot(robot) {}
		virtual ~RobotVis(){}
		
	virtual void Visualize( Model* mod, Camera* cam )
		{		
			// 		glPushMatrix();		
			// 		Gl::pose_inverse_shift( mod->GetGlobalPose() );
			
			//Color c = mod->GetColor();
			//c.a = 0.4;
			
			double x = robot->best_range * cos( robot->best_bearing );
			double y = robot->best_range * sin( robot->best_bearing );		
			
			mod->PushColor( Color(0,1,0,0.5) );
		//graph.Draw();
		//mod->PopColor();

		glBegin( GL_LINES );
		glVertex2f( 0,0 );
		glVertex2f( x, y );
		glEnd();

		
		// a sphere over the robot
		GLUquadric* quadric = gluNewQuadric();		
		gluQuadricDrawStyle( quadric, GLU_FILL );
		gluSphere( quadric, robot->position->GetGeom().size.x*4.0, 16, 8  );
		gluDeleteQuadric( quadric );

		mod->PopColor();

		//		glPopMatrix();

		}
	} vis; // instance;
};





// Stage calls this when the model starts up
extern "C" int Init( Model* mod )
{
	new Robot( (ModelPosition*)mod,
						 (ModelRanger*)mod->GetUnusedModelOfType( "ranger" ),
						 (ModelFiducial*)mod->GetUnusedModelOfType( "fiducial"  ) );
  return 0; //ok
}

double anglediff( double a, double b )
{
	return( fmod( a + M_PI -  b, M_PI*2.0) - M_PI);
}


int Robot::RangerUpdate()
{  	
  // compute the vector sum of the sonar ranges	      
  double dx=0, dy=0;
  
	const std::vector<ModelRanger::Sensor>& sensors = ranger->GetSensors();

  // use the front-facing sensors only
  for( unsigned int i=0; i < 8; i++ )
	 {
		dx += sensors[i].range * cos( sensors[i].pose.a );
		dy += sensors[i].range * sin( sensors[i].pose.a );
	 }
  
  if( (dx == 0) || (dy == 0) )
		{
			//puts( "warning: no ranger data" );
			return 0;
		}

	double resultant_angle = atan2( dy, dx );
	double forward_speed = 0.0;
	double side_speed = 0.0;	   
	double turn_speed = EXPAND_WGAIN * resultant_angle;
	  
  // if the front is clear, drive forwards
  if( (sensors[3].range > SAFE_DIST) && // forwards
	  (sensors[4].range > SAFE_DIST) &&
	  (sensors[5].range > SAFE_DIST ) && //
	  (sensors[6].range > SAFE_DIST/2.0) && 
	  (sensors[2].range > SAFE_DIST ) && 
	  (sensors[1].range > SAFE_DIST/2.0) && 
	  (fabs( resultant_angle ) < SAFE_ANGLE) )
		{
			forward_speed = VSPEED;
			
			// and steer to match the heading of the nearest robot
			if( best )
				turn_speed += FLOCK_WGAIN * best_heading_error;
			else
				turn_speed = 0.0;
			
			// drift up
  		//if( fabs( anglediff( position->GetPose().a, 0.0 )) < 1.0 )
				//{	
 				//position->SetColor(Color::blue);
 				//turn_speed += 0.03;
				//}
			//else
			//	position->SetColor(Color::red);			
		}
  else
		{
			// front not clear. we might be stuck, so wiggle a bit
			if( fabs(turn_speed) < 0.1 )
				turn_speed = drand48();
		}
  
  position->SetSpeed( forward_speed, side_speed, turn_speed );
  
  return 0;
}

int Robot::FiducialUpdate()
{  	
  // find the best teammate
  
  double dist = 1e6; // big
  best = NULL;

	//double w_angle = 1.0;
	//double w_distance = 0.0;

  FOR_EACH( it, fiducial->GetFiducials() )
	{
	  ModelFiducial::Fiducial* other = &(*it);
	  
		// score others by range and distance
		
// 		double heading_score = (M_PI - fabs( other->bearing ));
// 		double distance_score = 1.0 / other->range;
		
// 		double score = heading_score * w_angle + distance_score * w_distance;
		
		// 	  if( score > dist )
		if( other->range < dist )
			{
				dist = other->range;
				best = other;
			}				
	}
	
	if( best ) 
		{
			best_bearing = best->bearing;
			best_range = best->range;
			best_heading_error = best->bearing;
			// become red
			position->SetColor( Color::red );
			
			//printf( "bearing %.2f\n", best_red->bearing );
		}
	else
		{
			//if( position->GetColor() == red )
			position->SetColor( Color::blue );			
		}
	
	//   else if( best ) // if we saw someone else
	// 	{
	// 		best_bearing = best->bearing;
	// 		best_range = best->range;
	// 		best_heading_error = best->geom.a;
	// 	}
	

  
  return 0;
}
